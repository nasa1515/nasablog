---
emoji: 🤦‍♂️
title: 쿠버네티스란? [Kubernetes]
date: "2021-06-29 00:06:25"
author: nasa1515
tags: Kubernetes
categories: Kubernetes
---


머리말  
 쿠버네티스... 이름만 많이 들어보고 많이 사용하는 기술이라고만 들었다.  
 하지만 온프레미스 경험만 가지고 있는 나는 아무것도 알지 못한다.  아마도 포스트를 작성하면서 조금씩 익숙해질 것이라고 생각한다.  
 마지막 포스트를 쓸 때 쯤에는 초급정도의 스킬은 가지고 있었으면 싶다.  

---

 참고 블로그 : https://subicura.com/2019/05/19/kubernetes-basic-1.html

---



## ✔ 쿠버네티스란??

  

![](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/kubernetes-logo.png)


* 쿠버네티스는 컨테이너를 쉽고 빠르게 ``배포/확장하고 관리를 자동화``해주는 오픈소스 플랫폼입니다.  

* 보통 k8s 또는 큐브 (kube) 라고 줄여서 부릅니다.

* 현재는 단순한 컨테이너 플랫폼이 아닌 ``마이크로서비스``, ``클라우드 플랫폼``을 지향하고  
컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 합니다.  
서버리스, CI/CD, 머신러닝 등 다양한 기능이 쿠버네티스 플랫폼 위에서 동작합니다.

<br/>

## ✌ 대표적인 쿠버네티스의 기능들 


### 쿠버네티스의 배포 방식
![](https://subicura.com/assets/article_images/2019-05-19-kubernetes-basic-1/workload.png)

* 컨테이너와 관련된 많은 예제가 ``웹(프론트엔드+백엔드)`` 애플리케이션을 다루고 있지만 실제론 더 다양한 형태의 APP이 있습니다.  
쿠버네티스는 ``Deployment``, ``StatefulSets``, ``DaemonSet``, ``Job``, ``CronJob``등 다양한 배포 방식을 지원합니다.  

- ``Deployment``는 새로운 버전의 애플리케이션을 다양한 전략으로 무중단 배포할 수 있습니다. 
* ``StatefulSets``은 실행 순서를 보장하고 호스트 이름과 볼륨을 일정하게  
사용할 수 있어 순서나 데이터가 중요한 경우에 사용할 수 있습니다. 

* ``DaemonSet``은 로그나 모니터링 등 모든 노드에 설치가 필요한 경우에 사용 할 수 있습니다.

* ``Job, CronJob``을 이용해 배치성 작업을 할 수도 있습니다.

<br/>

### CLOUD 지원

![스크린샷, 2020-08-19 18-16-09](https://user-images.githubusercontent.com/69498804/90616176-12411800-e248-11ea-8e9e-b79e49051a66.png)

* 쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능 ``AutoScaling`` 기능을 가지고 있으며 LoadBalancer로 사용할 수 있습니다. 

* 외부 스토리지를 컨테이너 내부에 마운트해 사용도 가능한데 이를 위해 클라우드 별로 적절한 API를 사용하는 모듈이 필요합니다.

* 쿠버네티스는 ``Cloud Controller``를 이용하여 클라우드 연동을 손쉽게 확장할 수 있습니다.  
``AWS, GCP, AZURE``는 물론 ``다양한 모듈``을 제공해 동일한 설정 파일을 서로 다른 클라우드에서 동일하게 사용할 수 있습니다.


<br/>

### NAMESPACE & LABEL

![스크린샷, 2020-08-20 09-42-17](https://user-images.githubusercontent.com/69498804/90703714-722bd300-e2c9-11ea-927f-e4e2e4fdc719.png)

* 쿠버네티스에서는 1개의 클러스터를 ``논리적으로 구분``하여 사용할 수 있습니다. 

* 하나의 클러스터에 다양한 프레임워크와 애플리케이션을 설치하기 때문에 기본(system, default)외에 여러 개의 네임스페이스를 사용하는 것이 당연합니다.   

* 더 세부적으로 ``라벨 기능``을 적극적으로 사용하여 유연하고, 확장성 있게 리소스를 관리할 수 있습니다.



<br/>

### Auto Scaling




k8s는 ``CPU``, ``memory`` 사용량에 따른 확장은 기본이고 현재 접속자 수와 같은 값을 사용할 수도 있습니다.  

총 세개의 방식이 대표적인데 아래와 같습니다.  

* ``Horizontal Pod Autoscaler(HPA)`` : 컨테이너의 개수를 조정
![스크린샷, 2020-08-20 09-47-14](https://user-images.githubusercontent.com/69498804/90703962-23326d80-e2ca-11ea-934d-86b32cfdd145.png)

<br/>

* ``Vertical Pod Autoscaler(VPA)``: 컨테이너의 리소스 할당량을 조정 
![스크린샷, 2020-08-20 09-50-15](https://user-images.githubusercontent.com/69498804/90704099-8f14d600-e2ca-11ea-9e20-1cd1837fa9b2.png)

<br/>

* ``Cluster Autosclaer(CA)`` : 서버 개수(노드 수) 를 조정 


<br/>


### 쿠버네티스의 단점  

* 컨테이너라는 개념조차도 처음 접해보는 초보자에게는 ``쿠버네티스``는 복잡하고 초반 개념을 이해하기 매우 어렵습니다.

* ``YAML 설정 파일``은 매우 많고 클러스터를 만드는 것도 쉽지 않습니다. 

* 즉 오래동안 사용해보지 않는 사람을 제외한 초기사용자에겐 진입장벽이 높습니다


---

## ✌ 쿠버네티스의 기본 로직, 및 개념 


* ``Desired State``

    ![스크린샷, 2020-08-20 09-59-42](https://user-images.githubusercontent.com/69498804/90704590-e10a2b80-e2cb-11ea-95dd-9553e597fd69.png)


* ``k8s``에서 가장 중요한 것은 ``desired state`` - ``원하는 상태`` 라는 개념이라고 합니다.  

<br/>

* ``원하는 상태``라 함은 관리자가 원하는 환경을 의미하고  
    구체적으로는 몇대의 웹서버가 떠 있으면 좋은지, 몇 번 포트를 사용하길 원하는지 등을 말합니다.

<br/>

* k8s는 복잡한 작업을 하지만 자세히 들여다보면 ``현재 상태 (current state)``를 모니터링하면서  
관리자가 설정한 상태를 유지하려 내부적으로 작업을 하는 로직을 가지고 있습니다.

<br/>

* 이 개념 때문에 관리자가 배포할 때 직접적인 동작을 명령하지 않고 상태를 선언하는 방식을 사용합니다.

<br/>

* 예를 들어 “nginx 컨테이너를 실행해줘. 그리고 80 포트로 오픈해줘라는 것은”  

    * ``명령(imperative)`` :  nginx 컨테이너 실행, 80포트로 서비스 (현재 상태 변경)
    * ``선언(declarative)`` : 80 포트를 오픈한 nginx 컨테이너를 1개 유지해


* 말로 풀어쓰니깐 약간 이해가 안되는데 아래의 ``CLI`` 명령을 보면 이해가 될 것입니다.

    ```
    $ docker run                    # 명령 (imperative)
    $ kubectl create 
    # 상태 생성
    ```

    k8s의 ``핵심은 상태``입니다. k8s를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 아는 것이 가장 중요합니다

<br/>

---

## 👌 아키텍처

* 컨테이너는 아주 심플하고 우아하게 동작합니다.  

* 즉 ``run``을 하면 실행되고 ``stop``을 하면 멈춥니다.
* ``서버-클라이언트`` 구조를 안다면 컨테이너를 관리하는 에이전트를 만들고  
중앙에서 ``API``를 사용해 원격으로 관리하는 로직을 그릴 수 있을 것입니다.


    ![스크린샷, 2020-08-20 10-16-16](https://user-images.githubusercontent.com/69498804/90705561-31828880-e2ce-11ea-9b8b-5e6c4d725632.png)

* ks8 또한 ``Master``에 ``API 서버와 상태 저장소``를 두고 각 ``Node``의 ``에이전트(kubelet)``와 통신하는 구조입니다.  

---

## 👍 마스터 - 노드 구조
![스크린샷, 2020-08-20 10-21-31](https://user-images.githubusercontent.com/69498804/90705892-ecab2180-e2ce-11ea-8226-f235801c05ab.png)


* k8s는 ``전체 클러스터를 관리``하는 ``마스터``와 ``컨테이너가 배포``되는 ``노드``로 구성되어 있습니다.  

* 모든 명령은 ``마스터의 API 서버를 호출``하고 노드는 마스터와 통신하면서 필요한 작업을 수행합니다.  

* 특정 노드에 명령하거나 로그를 조회할 때도 노드에 직접 명령하는 게 아닌  
 마스터에 명령을 내리고 마스터가 노드에 접속하여 대신 결과를 응답합니다.

<br/>

**Master**  

* ``MASTER``는 다양한 모듈이 확장성을 고려하여 기능별로 쪼개져 있는 것이 특징 입니다.  

* 그러다 보니 보안 설정에 심혈을 기울여야 합니다.
* 마스터 서버 장애시 클러스터를 관리할 수 없기 때문에 보통 여러대로 구성하여 안정성을 높입니다.  


<br/>

**Node**

* ``NODE``는 ``MASTER``와 통신하면서 필요한 Pod을 생성하고 네트워크와 볼륨을 설정합니다.  

* ``실제 컨테이너들이 생성되는 곳``으로 거의 수천대로 확장할 수 있습니다.  
* ``추가적으로 라벨기능``을 사용하게되면 각각의 서버에 라벨을 붙여 사용목적(GPU 특화, SSD 서버 등)을 정의할 수 있습니다.

<br/>


**Kubectl**

* API 서버는 json 또는 protobuf 형식을 이용한 http 통신을 지원합니다.

* 보통 kubectl이라는 명령행 도구를 사용합니다.  (매우 편함!!)

<br/>

---

### Master 구성 요소


![스크린샷, 2020-08-20 10-47-13](https://user-images.githubusercontent.com/69498804/90707414-845e3f00-e2d2-11ea-881a-c754f08739cb.png)

<br/>

### API 서버 kube-apiserver  

* API 서버는 ``모든(ALL) 요청을 처리하는 마스터의 핵심 모듈``입니다.  

* kubectl의 요청과 더불어 ``내부 모듈``의 요청도 처리하고, 권한을 체크하여 요청을 거부할 수 있습니다.    
    
* 실제로 하는 일은 ``원하는 상태``를 ``key-value 저장소``에 저장하고 저장된 상태를 조회하는 매우 단순한 작업입니다.  
    
* ``Pod을 노드에 할당``하고 상태를 체크하는 일은 다른 모듈로 분리되어 있습니다.  
    노드에서 실행 중인 컨테이너의 로그를 보여주고 명령을 보내는 등 ``디버거 역할``도 수행합니다.

    ``즉!!!! 마스터는 엄마입니다!!``

<br/>

### 분산 데이터 저장소 etcd  

* ``RAFT 알고리즘``을 이용한 ``key-value 저장소``입니다.  
 
* 여러 개로 분산하여 복제할 수 있기 때문에 안정성이 높고 속도가 빠릅니다.  

* 단순히 값을 저장하고 읽는 기능뿐 아니라 ``watch 기능``이 있어 어떤 상태가 변경되면 바로 체크하여 로직을 실행할 수 있습니다.

* ``클러스터의 모든 설정``, ``상태 데이터``는 여기 저장되고 나머지 모듈은 stateless하게 동작하기 때문에    
``etcd``만 잘 백업해두면 언제든지 클러스터를 복구할 수 있습니다.  

* ``etcd는 오직 API 서버와 통신``하고 다른 모듈은 API 서버를 거쳐 etcd 데이터에 접근합니다.  


<br/>

### 스케줄러, 컨트롤러

* API 서버는 요청 시 etcd 저장소와 통신할 뿐 ``실제로 상태를 바꾸는 건 스케줄러와 컨트롤러`` 입니다.  

* ``현재 상태``를 모니터링하다가 원하는 상태와 다르면 맡은 작업을 수행하고 상태를 갱신합니다.

    <br/>

    * ``스케줄러 kube-scheduler``  

        스케줄러는 할당되지 않은 ``Pod을 여러 가지 조건(필요한 자원, 라벨)``에 따라 적절한 노드 서버에 할당해주는 모듈입니다.


    <br/>

    * ``큐브 컨트롤러 kube-controller-manager``

        큐브 컨트롤러는 다양한 역할을 하는 아주 바쁜 모듈입니다.  
        k8s에 있는 거의 ``모든 오브젝트의 상태를 관리``합니다. 오브젝트별로 철저하게 분업화되어  
        Deployment는 ReplicaSet을 생성하고 ReplicaSet은 Pod을 생성하고 Pod은 스케줄러가 관리하는 식입니다.

    <br/>

    * ``클라우드 컨트롤러 cloud-controller-manager``  
    
        클라우드 컨트롤러는 ``AWS, GCE, Azure 등 클라우드에 특화``된 모듈입니다.  
         ``노드를 추가/삭제``하고 ``로드 밸런서를 연결``하거나 볼륨을 붙일 수 있습니다.  
         각 클라우드 업체에서 자체 모듈을 만들어 제공하고 있습니다.

<br/>

---

### Node 구성 요소
![스크린샷, 2020-08-20 10-57-25](https://user-images.githubusercontent.com/69498804/90708077-f08d7280-e2d3-11ea-9e24-eb5e0f52430a.png)

<br/>

**큐블릿 kubelet**   

* 노드에 할당된 Pod의 생명주기를 관리합니다.  
* ``Pod을 생성``하고 Pod 안 컨테이너에 이상을 확인하면서 ``주기적으로 마스터에 상태를 전달``합니다.  

* API 서버의 요청을 받아 컨테이너의 로그를 전달하거나 ``특정 명령을 대신 수행``하기도 합니다.

<br/>

**프록시 kube-proxy**  

* 프록시는 Pod으로 연결되는 ``네트워크를 관리``합니다.  

* ``TCP, UDP, SCTP 스트림을 포워딩``하고  
여러 개의 Pod을 ``라운드로빈 형태``로 묶어 서비스를 제공할 수 있습니다.  

* 현재는 요청에 대한 처리를 ``iptables를 설정하는 방식으로 변경``되었습니다.  
    하지만 iptables에 등록된 규칙이 많아지면 ``느려지는 문제`` 때문에 최근 ``IPVS``를 지원하기 시작했습니다.

<br/>

**추상화**

* 컨테이너는 도커고 도커가 컨테이너라고 생각해도 무리가 없는 상황입니다만 

* k8s는 ``CRI(Container runtime interface)``를 구현한 다양한 컨테이너 런타임을 지원합니다.  

* CRI 외에 ``CNI(네트워크)``, ``CSI(스토리지)``를 지원하여 쉽게 확장하여 사용할 수 있습니다.

<br/>

---
 
### K8S의 전체적인 로직 요약

![스크린샷, 2020-08-20 11-05-54](https://user-images.githubusercontent.com/69498804/90708580-1ff0af00-e2d5-11ea-9102-75dd7cf923ff.png)

---

```toc
```