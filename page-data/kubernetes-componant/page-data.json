{"componentChunkName":"component---src-templates-blog-template-js","path":"/kubernetes-componant/","result":{"data":{"cur":{"id":"f7b5524d-5df4-5975-baf4-be92f59dc22a","html":"<p>머리말  </p>\n<p>이전 포스트에서 드디어 GCP 인스턴스 기반의 k8s 클러스터 환경을 구축했습니다.<br>\n이번 포스트에서는 이번에 간단하게 포스트해서 정리했지만 실제 실습을 들어가기전 전체적인 개념에 대해서 다시 한번 정리하고<br>\n실습에 들어가야 할 것 같아서 조대협님의 블로그 글을 참고하여 내 식대로 다시 정리해보았다.  </p>\n<hr>\n<p>참고  :  <a href=\"https://bcho.tistory.com/1256\">조대협님 블로그</a></p>\n<hr>\n<h2 id=\"-개념정리\" style=\"position:relative;\"><a href=\"#-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC\" aria-label=\" 개념정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✔ 개념정리</h2>\n<h3 id=\"오브젝트\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8\" aria-label=\"오브젝트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오브젝트</h3>\n<p>쿠버네티스를 이해하기 위해 가장 중요한 부분이 <code class=\"language-text\">오브젝트</code>이다.<br>\n가장 <code class=\"language-text\">기본적인 구성단위</code>가 되는 <code class=\"language-text\">기본 오브젝트(Basic object)</code> 를 <code class=\"language-text\">생성</code>하고 <code class=\"language-text\">관리</code>하는 추가적인 기능을 가진 <code class=\"language-text\">컨트롤러(Controller)</code><br>\n이러한 오브젝트의 <code class=\"language-text\">스펙(설정)</code>이외에 추가정보인 <code class=\"language-text\">메타 정보</code>들로 구성이 된다고 보면 된다. </p>\n<br/>\n<h3 id=\"오브젝트-스펙-object-spec\" style=\"position:relative;\"><a href=\"#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%8A%A4%ED%8E%99-object-spec\" aria-label=\"오브젝트 스펙 object spec permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오브젝트 스펙 (Object Spec)</h3>\n<p>오브젝트들은 모두 오브젝트의 특성 (설정정보)을 기술한 오브젝트 스펙 (Object Spec)으로 정의가 되고,<br>\n커맨드 라인을 통해서 오브젝트 생성 시 인자로 전달하여 정의를 하거나 또는 <code class=\"language-text\">yaml</code>이나 <code class=\"language-text\">json</code> 파일로 <code class=\"language-text\">스펙을 정의</code>할 수 있다. </p>\n<br/>\n<h3 id=\"기본-오브젝트-basic-object\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-basic-object\" aria-label=\"기본 오브젝트 basic object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 오브젝트 (Basic Object)</h3>\n<p>쿠버네티스에 의해서 배포 및 관리되는 가장 기본적인 오브젝트는<br>\n컨테이너화되어 배포되는 애플리케이션의 워크로드를 기술하는 오브젝트로 4가지가 있다.   </p>\n<ul>\n<li>Pod : 컨테이너화된 애플리케이션</li>\n<li>Service : 로드밸런서</li>\n<li>Volume : 디스크</li>\n<li>Namespace : 패키지</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"-pod\" style=\"position:relative;\"><a href=\"#-pod\" aria-label=\" pod permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✌ Pod</h2>\n<p>Pod 는 쿠버네티스에서 <code class=\"language-text\">가장 기본적인 배포 단위</code>로, 컨테이너를 포함하는 단위이다.</p>\n<p>k8s의 특징중의 하나는 컨테이너를 하나씩 배포하는 것이 아니라<br>\nPod 라는 단위로 배포하는데, Pod는 하나 이상의 컨테이너를 포함한다.</p>\n<p>간단한 Pod를 정의한 오브젝트 스펙이다</p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\">apiVersion<span class=\"token punctuation\">:</span> <span class=\"token class-name\">v1</span>\nkind<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Pod</span>\nmetadata<span class=\"token punctuation\">:</span>\nname<span class=\"token punctuation\">:</span> <span class=\"token class-name\">nginx</span>\nspec<span class=\"token punctuation\">:</span>\ncontainers<span class=\"token punctuation\">:</span>\n<span class=\"token operator\">-</span> name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">nginx</span>\n    image<span class=\"token punctuation\">:</span> nginx<span class=\"token punctuation\">:</span><span class=\"token number\">1.7</span><span class=\"token number\">.9</span>\n    ports<span class=\"token punctuation\">:</span>\n    <span class=\"token operator\">-</span> containerPort<span class=\"token punctuation\">:</span> <span class=\"token number\">8090</span></code></pre></div>\n<br/>\n<ul>\n<li><code class=\"language-text\">apiVersion</code> :  이 스크립트를 실행하기 위한 쿠버네티스 API 버전 (보통 v1을 사용한다)</li>\n<li><code class=\"language-text\">kind</code> : 리소스의 종류를 정의, (Pod)</li>\n<li><code class=\"language-text\">metadata</code> : 리소스의 각종 메타 데이타 정의 <code class=\"language-text\">라벨</code>이나 <code class=\"language-text\">리소스의 이름</code> 등 각종 메타데이타를 넣는다.  </li>\n<li>\n<p><code class=\"language-text\">spec</code> : 리소스에 대한 <code class=\"language-text\">상세한 스펙</code>을 정의한다.</p>\n<ul>\n<li>Pod는 컨테이너를 가지고 있기 때문에, container 를 정의  </li>\n<li>이름은 <code class=\"language-text\">nginx</code> </li>\n<li><code class=\"language-text\">도커 이미지 nginx:1.7.9</code> 를 사용  </li>\n<li><code class=\"language-text\">컨테이너 포트 8090을 오픈</code>한다.</li>\n</ul>\n</li>\n</ul>\n<br/>\n<br/>\n<p>여기서 의문 하나!!!<br>\n도대체 왜 Pod 안에 한개 이상의 컨테이너를 가지고 있음에도<br>\n개별적으로 하나씩 컨테이너를 배포하지 않고 여러개의 컨테이너를 Pod 단위로 묶어서 배포할까?</p>\n<p>Pod는 다음과 두가지 특징을 가지고 있기 때문이다.  </p>\n<ul>\n<li>\n<p><code class=\"language-text\">Pod 내의 컨테이너는 IP와 Port를 공유한다.</code>   </p>\n<p><code class=\"language-text\">두 개의 컨테이너</code>가 <code class=\"language-text\">하나의 Pod를 통해서 배포</code>되었을때 localhost를 통해서 통신이 가능하다.  </p>\n<p>컨테이너 <code class=\"language-text\">A가 8080</code>, 컨테이너 <code class=\"language-text\">B가 7001</code>로 배포가 되었을 때<br>\n<code class=\"language-text\">B -> A</code>를 호출 할 때 <code class=\"language-text\">localhost:8080 으로 호출</code>하면 되고<br>\n<code class=\"language-text\">A -> B</code>를 호출 할 때는 <code class=\"language-text\">localhost:7001로 호출</code>이 가능하다. </p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">Pod 내에 배포된 컨테이너간에는 디스크 볼륨을 공유할 수 있다.</code>   </p>\n<p>요즘 APP은 실행할때 APP만 올라가는것이 아니라 <code class=\"language-text\">Reverse proxy</code>, <code class=\"language-text\">로그 수집기</code>등 다양한 주변 솔루션이 같이 배포 된다.    </p>\n<p><code class=\"language-text\">APP(Tomcat, node.js)</code>와 로그 수집기를 다른 컨테이너로 배포하면 일반적인 경우 컨테이너에 의해서 <code class=\"language-text\">파일 시스템이 분리</code>되기 때문에<br>\n로그 수집기가 APP 컨테이너의 로그파일을 읽는 것이 불가능 하다.<br>\n하지만 k8s는 하나의 Pod 내에서 컨테이너들끼리 볼륨을 공유할 수 있기 때문에 다른 컨테이너의 파일을 읽어올 수 있다.</p>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"-volume\" style=\"position:relative;\"><a href=\"#-volume\" aria-label=\" volume permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👍 Volume</h2>\n<p>간단하게 요약해서 볼륨은 외장디스크라고 이해하면 된다.</p>\n<p>자세한 내용은 -> <a href=\"https://nasa1515.tech/kubernetes-volume/\">볼륨 정리</a> 에 정리된 포스트를 올려놓았다.</p>\n<br/>\n<hr>\n<h2 id=\"-service\" style=\"position:relative;\"><a href=\"#-service\" aria-label=\" service permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👌 Service</h2>\n<p><code class=\"language-text\">Pod</code>와 <code class=\"language-text\">볼륨</code>을 이용하여, 컨테이너들을 정의하고, Pod를 서비스로 제공할 때 분산환경에서는 하나의 Pod로 서비스 하는 경우는 드물고<br>\n여러 Pod를 <code class=\"language-text\">로드밸런서를 이용해서 하나의 IP와 포트</code>로 묶어 서비스를 제공한다.</p>\n<p>Pod의 경우에는 동적으로 생성 되고, 장애가 생기면 자동으로 재시작 되며 IP가 바뀌기 때문에<br>\n<code class=\"language-text\">로드밸런서</code>에서 Pod의 목록을 지정할 때는 IP주소를 이용하는 것은 어렵다. 또 <code class=\"language-text\">오토 스케일링</code>으로 인하여 <code class=\"language-text\">Pod 가 동적으로 추가 또는 삭제</code>되기 때문에 이렇게 추가/삭제된 Pod 목록을 로드밸런서가 유연하게 선택해 줘야 한다.</p>\n<br/>\n<p>그래서 사용하는 것이 <code class=\"language-text\">라벨(label)</code>과 <code class=\"language-text\">라벨 셀렉터(label selector)</code> 라는 개념이다.</p>\n<ul>\n<li><code class=\"language-text\">라벨 셀렉터(label selector)</code> : 어떤 Pod를 서비스로 묶을 것인지 정의<br>\n</li>\n</ul>\n<p>각 Pod를 생성할때 <code class=\"language-text\">메타데이타 정보 부분</code>에 <code class=\"language-text\">라벨을 정의</code>할 수 있다.<br>\n서비스는 라벨 셀렉터에서 특정 라벨을 가지고 있는 Pod만 선택하여 서비스에 묶게 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/91119584-7d6a6e80-e6ce-11ea-805b-199d8c7e1e24.png\" alt=\"스크린샷, 2020-08-25 12-28-23\"></p>\n<p>그림설명 : 라벨이 <code class=\"language-text\">“myapp”</code>인 서비스만 분류해 서비스에 넣는다. 분류된 Pod 간 <code class=\"language-text\">로드밸런싱</code>을 통하여 외부로 서비스를 제공</p>\n<br/>\n<p>위 서비스를 스펙으로 정의해보자</p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\">kind<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Service</span>\napiVersion<span class=\"token punctuation\">:</span> <span class=\"token class-name\">v1</span>\nmetadata<span class=\"token punctuation\">:</span>\nname<span class=\"token punctuation\">:</span> my<span class=\"token operator\">-</span><span class=\"token class-name\">service</span>\nspec<span class=\"token punctuation\">:</span>\nselector<span class=\"token punctuation\">:</span>\n    app<span class=\"token punctuation\">:</span> <span class=\"token class-name\">myapp</span>\nports<span class=\"token punctuation\">:</span>\n<span class=\"token operator\">-</span> protocol<span class=\"token punctuation\">:</span> <span class=\"token class-name\">TCP</span>\n    port<span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n    targetPort<span class=\"token punctuation\">:</span> <span class=\"token number\">9376</span></code></pre></div>\n<br/>\n<ul>\n<li><code class=\"language-text\">kind</code> : Service로 지정</li>\n<li><code class=\"language-text\">apiVersion</code> : v1으로 정의</li>\n<li><code class=\"language-text\">metadate-name</code> : my-service (서비스의 이름)</li>\n<li><code class=\"language-text\">spec</code> : 서비스에 대한 스펙을 정의</li>\n<li><code class=\"language-text\">selector</code> : 라벨 = <code class=\"language-text\">app:myapp</code>인 Pod 만을 선택해서 분류</li>\n<li><code class=\"language-text\">ports</code><br>\n<code class=\"language-text\">protocol</code> : TCP<br>\n<code class=\"language-text\">port</code> : 80 포트로 서비스\n<code class=\"language-text\">targetPort</code> : 80 포트 요청을 컨테이너의 9376 포트로 연결해 제공한다 </li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"-name-space\" style=\"position:relative;\"><a href=\"#-name-space\" aria-label=\" name space permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👏 Name space</h2>\n<p>하나의 쿠버네티스 클러스터내의 <code class=\"language-text\">논리적인 분리 단위</code>라고 보면 된다.</p>\n<p><code class=\"language-text\">Pod,Service</code> 등은 <code class=\"language-text\">네임 스페이스 별</code>로 생성이나 관리가 되고 사용자의 권한 역시 네임 스페이스 별로 나눠서 부여할 수 있다.</p>\n<p>즉 하나의 클러스터 내에 <code class=\"language-text\">개발/운영/테스트 환경</code>이 있으면  클러스터를 <code class=\"language-text\">개발/운영/테스트</code> 3개의 네임 스페이스로 나눠 운영이 가능하다. </p>\n<br/>\n<p><code class=\"language-text\">네임스페이스 동작</code></p>\n<ul>\n<li>사용자 별로 네임스페이스 별 접근 권한을 다르게 운영할 수 있다.</li>\n<li>네임스페이스별로 리소스의 할당량을 지정할 수 있다 즉 사용 가능한 리소스의 수를 지정할 수 있다.<br>\n(ex : 개발팀 CPU 100, 운영팀 CPU 200) </li>\n<li>네임 스페이스별로 리소스를 나눠서 관리할 수 있다. (Pod, Service 등)</li>\n</ul>\n<br/>\n<p>하지만 네임 스페이스는 <code class=\"language-text\">논리적인 분리 단위</code>일뿐 물리적이나 장치를 통해서 환경을 분리(Isolation)한 것이 아니다.<br>\n즉 다른 네임 스페이스간의 pod 라도 통신은 가능하다.   </p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/91120605-04204b00-e6d1-11ea-8f6c-20393369c6d7.png\" alt=\"스크린샷, 2020-08-25 12-46-31\">\n그림과 같이 네임스페이스를 분리하여 운영이 가능하다!!!</p>\n<p><a href=\"https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-organizing-with-namespaces\">네임스페이스 참고 글</a></p>\n<br/>\n<hr>\n<h2 id=\"-라벨label\" style=\"position:relative;\"><a href=\"#-%EB%9D%BC%EB%B2%A8label\" aria-label=\" 라벨label permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🐱‍🏍 라벨(label)</h2>\n<p>라벨은 쿠버네티스의 <code class=\"language-text\">리소스를 선택</code>하는데 사용이 된다.<br>\n각 리소스는 라벨을 가질 수 있고 라벨 검색 조건에 따라서 특정 라벨을 가지고 있는 리소스만을 선택할 수 있다.</p>\n<p>라벨을 선택하여 특정 리소스만 배포, 업데이트 할 수 있고 또는 라벨로 선택된 리소스만 Service에 연결하거나<br>\n특정 라벨로 선택된 리소스에만 네트워크 접근 권한을 부여하는 등이 가능하다.</p>\n<p>라벨은 metadata 섹션에 키/값 쌍으로 정의가 가능하며 하나의 리소스에는 하나의 라벨이 아니라 여러 라벨을 동시에 적용할 수 있다.</p>\n<br/>\n<p>이해가 가장 빠른건 역시 정의!</p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\"><span class=\"token string\">\"metadata\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n<span class=\"token string\">\"labels\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"key1\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"value1\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"key2\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"value2\"</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">셀렉터</code>를 사용하려면 오브젝트 스펙에서 selector 라고 정의하고 라벨 조건을 적어 놓으면 된다. </p>\n<br/>\n<p>k8s는 두 가지 셀렉터를 제공한다. 기본적으로 <code class=\"language-text\">Equaility based selector</code>와 <code class=\"language-text\">Set based selector</code> 이다.</p>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">Equality based selector</code> : 같냐, 다르냐와 같은 조건을 이용하여, 리소스를 선택하는 방법</p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\">environment <span class=\"token operator\">=</span> dev\n\ntier <span class=\"token operator\">!=</span> frontend</code></pre></div>\n<p>같이 등가 조건에 따라서 리소스를 선택한다.</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">set based selector</code> : Equality based 보다 향상된 셀렉터로 집합의 개념을 사용한다.</p>\n<ul>\n<li>environment in (production,qa) 는 environment가 production 또는 qa 인 경우 </li>\n<li>tier notin (frontend,backend)는 frontend도 아니고 backend도 아닌 리소스를 선택.</li>\n</ul>\n<p>아래 nasa-service 라는 이름의 서비스를 정의했다.<br>\n셀렉터에서 app: myapp 정의해서 Pod의 라벨 app이 myapp 것만 골라 이 서비스에 바인딩해서 9376 포트로 서비스 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\">kind<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Service</span>\napiVersion<span class=\"token punctuation\">:</span> <span class=\"token class-name\">v1</span>\nmetadata<span class=\"token punctuation\">:</span>\nname<span class=\"token punctuation\">:</span> my<span class=\"token operator\">-</span><span class=\"token class-name\">service</span>\nspec<span class=\"token punctuation\">:</span>\nselector<span class=\"token punctuation\">:</span>\n    app<span class=\"token punctuation\">:</span> <span class=\"token class-name\">myapp</span>\nports<span class=\"token punctuation\">:</span>\n<span class=\"token operator\">-</span> protocol<span class=\"token punctuation\">:</span> <span class=\"token class-name\">TCP</span>\n    port<span class=\"token punctuation\">:</span> <span class=\"token number\">80</span>\n    targetPort<span class=\"token punctuation\">:</span> <span class=\"token number\">9376</span></code></pre></div>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"-컨트롤러\" style=\"position:relative;\"><a href=\"#-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\" aria-label=\" 컨트롤러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎶 컨트롤러</h2>\n<p>앞에 있는 4개의 기본 오브젝트로, 애플리케이션을 설정하고 배포하는 것이 가능하다.<br>\n이를 조금 더 편리하게 관리하기 위해서 컨트롤러라는 개념을 사용한다.</p>\n<p>컨트롤러는 기본 오브젝트들을 생성하고 이를 관리하는 역할을 해준다. 컨트롤러의 종류는 아래와 같다.</p>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">Replication Controller</code> : Pod를 관리해주는 역할, 지정된 숫자로 Pod를 기동, 관리하는 역할을 한다. </p>\n<p>Replication Controller (RC)는 크게 3가지 파트로 구성되는데 아래와 같다.  </p>\n<ul>\n<li>Replica의 수</li>\n<li>Pod Selector</li>\n<li>Pod Template</li>\n</ul>\n</li>\n</ul>\n<br/>\n<ul>\n<li>Selector : 먼저 Pod selector는 라벨 기반이며, RC가 관리한 Pod를 가지고 오는데 사용한다.</li>\n<li>Replica 수 :  RC에 의해서 관리되는 Pod의 수, 그 숫자만큼 Pod 의 수를 유지하도록 한다.  </li>\n<li>Pod template : Pod에 대한 정보 (도커 이미지, 포트,라벨등)에 대한 정보를 정의 한다.</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p>아래 예를 보자.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93280269-299e0180-f804-11ea-91ff-a8648eca6c19.png\" alt=\"스크린샷, 2020-09-16 10-00-43\"></p>\n<p>ngnix라는 이름의 RC를 정의한 것으로<br>\nlabel이 “app:ngnix”인 Pod들을 관리하고 3개의 Pod가 항상 운영되도록 설정한다.</p>\n<p>Pod는 app:ngnix 라는 라벨을 가지며, 이름이 ngnix이고 nginx 이미지를 사용해서 생성하고<br>\n컨테이너의 포트는 80 번 포트를 이용해서 서비스를 제공한다.</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<h3 id=\"replicaset\" style=\"position:relative;\"><a href=\"#replicaset\" aria-label=\"replicaset permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ReplicaSet</h3>\n<p>Replication Controller 의 업데이트 버전으로 생각하면 된다.<br>\nReplicaSet이 나옴으로 써 RC는 거의 사용하지 않는다.\n두 서비스의 큰 차이는 없고<br>\nReplication Controller 는 Equality 기반 Selector를 이용하고<br>\nReplica Set은 Set 기반의 Selector를 이용한다. </p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<h3 id=\"deployment\" style=\"position:relative;\"><a href=\"#deployment\" aria-label=\"deployment permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Deployment</h3>\n<p>Replication controller와 Replica Set의 좀더 상위 추상화 개념이다.<br>\n실제 운영에서는 RS 나 RC를 바로 사용하는 것보다,  좀 더 추상화된 Deployment를 사용하게 된다.</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"-쿠버네티스-배포에-대한-이해\" style=\"position:relative;\"><a href=\"#-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%B0%ED%8F%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4\" aria-label=\" 쿠버네티스 배포에 대한 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>😃 쿠버네티스 배포에 대한 이해</h2>\n<p>쿠버네티스의 Deployment 리소스를 이해하기 위해서<br>\n쿠버네티스에서 Deployment 없이 어떻게 배포를 하는지에 대해서 이해를 해야 한다.  </p>\n<br/>\n<p>다음과 같은 Pod와 RC가 있다</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93280666-26574580-f805-11ea-9f51-8bd65e77f541.png\" alt=\"스크린샷, 2020-09-16 10-12-28\"></p>\n<p>이제 애플리케이션이 업데이트되서 새로운 버전으로 컨테이너를 굽고 이 컨테이너를 배포하는 시나리오에 대해서 알아보자.<br>\n여러가지 배포 전략이 있겠지만, 두가지 방법에 대해서만 설명해보자.</p>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">블루/그린 배포</code><br>\n블루(예전)버전으로 서비스 하고 있던 시스템을 그린(새로운)버전을 배포한 후 트래픽을 블루에서 그린으로 한번에 돌리는 방식이다.<br>\n여러 방법이 있지만 손쉬운 방법은 새로운 RC을 만들어 새로운 템플릿으로 Pod를 생성한 뒤<br>\nPod 생성이 끝나면, 서비스를 새로운 Pod로 옮기는 방식이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93282744-08401400-f80a-11ea-8300-956f40553998.png\" alt=\"스크린샷, 2020-09-16 10-46-55\">\n후에, 배포가 완료되고 문제가 없으면 예전 버전의 RC 와 Pod를 지워준다.</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">롤링 업데이트 방식</code><br>\nPod를 하나씩 업그레이드 해가는 방식이다.  </p>\n<p>[1] 이 배포를 위해선 먼저 새로운 RC를 만든 뒤 기존 RC에서 replica 수를 하나 줄이고, 새로운 RC에는 replica 수를 하나만 준다.\n<img src=\"https://user-images.githubusercontent.com/69498804/93283005-96b49580-f80a-11ea-94b1-0bd5e70cee5e.png\" alt=\"스크린샷, 2020-09-16 10-51-30\">\n라벨이 동일하면 서비스는 자연히 새로운 RC에 의해 생성된 Pod를 서비스에 포함 시킨다.</p>\n<br/>\n<p>[2] 다음으로 기존 RC의 replica를 하나 더 줄이고, 새로운 RC의  replica를 하나 더 늘린다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93283148-ea26e380-f80a-11ea-8df7-0fbed12ab227.png\" alt=\"스크린샷, 2020-09-16 10-53-50\"></p>\n<br/>\n<p>[3]이후 기존 Pod가 하나더 서비스에서 빠지게 되고 새로운 버전의 Pod가 서비스에 추가된다.</p>\n<p>위의 작업을 반복하게 되면 아래 그림과 같이 예전 버전의 Pod가 모두 빠지고 새 버전의 Pod만 서비스 되게 된다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93283242-193d5500-f80b-11ea-820d-83b9e1408570.png\" alt=\"스크린샷, 2020-09-16 10-55-11\"></p>\n<p>만약 배포가 잘못되었을 경우에는 기존 RC의 replica 수를 원래대로 올리고<br>\n새버전의 replicat 수를 0으로 만들어서 예전 버전의 Pod로 롤백이 가능하다.</p>\n<p>이 과정은 kubectl rolling-update라는 명령으로 RC 단위로 컨트롤이 가능하지만<br>\n그래도 여전히 작업이 필요하고, 배포 과정을 모니터링 해야 한다.<br>\n그리고 가장 큰 문제는 kubectl rolling-update 명령은 클라이언트에서 실행 하는 명령으로<br>\n명령어 실행중에 클라이언트의 연결이 끊어 지면 배포작업이 비정상적으로 끊어질 수 있는 문제가 있다. </p>\n<p>추가적으로, 롤백과정 역시 수동 컨트롤이 필요할 수 있다. 그래서 이러한 과정을 자동화하고 추상화한 개념을 Deployment라고 보면 된다.</p>\n<p>Deployment는 Pod 배포를 위해서 RC를 생성하고 관리하는 역할을 하며<br>\n특히 롤백을 위한 기존 버전의 RC 관리등 여러가지 기능을 포괄적으로 포함하고 있다.\n<img src=\"https://user-images.githubusercontent.com/69498804/93283605-d3cd5780-f80b-11ea-8f30-080ffd0b8735.png\" alt=\"스크린샷, 2020-09-16 11-00-23\"></p>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"-고급-컨트롤러\" style=\"position:relative;\"><a href=\"#-%EA%B3%A0%EA%B8%89-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\" aria-label=\" 고급 컨트롤러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✨ 고급 컨트롤러</h2>\n<p>RC,RS,Deployment는 웹서버와 같은 일반적인 워크로드에 대해 Pod를 관리하기 위한 컨트롤러이다.<br>\n실제 운영환경에서는 웹서버 이외의 데이타베이스 ,배치 작업, 데몬 서버등과 같이<br>\n다양한 형태의 워크로드 모델이 존재하는데 이를 지원하기 위해 k8s는 다양한 컨트롤러를 제공한다. </p>\n<br/>\n<ul>\n<li>\n<h3 id=\"code-classlanguage-textdaemonsetcode\" style=\"position:relative;\"><a href=\"#code-classlanguage-textdaemonsetcode\" aria-label=\"code classlanguage textdaemonsetcode permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">DaemonSet</code></h3>\n<p>DaemonSet(DS)는 Pod가 각각의 노드에서 하나씩만 돌게 하는 형태로 Pod를 관리하는 컨트롤러이다.\n<img src=\"https://user-images.githubusercontent.com/69498804/93283921-74237c00-f80c-11ea-85b4-3fa482f66c84.png\" alt=\"스크린샷, 2020-09-16 11-04-50\"></p>\n<p>RC나 RS에 의해서 관리되는 Pod 는 노드의 상황에 따라서 일반적으로 비균등적으로 배포가 되지만<br>\nDS에 의해 관리되는 Pod는 모든 노드에 균등하게 <code class=\"language-text\">하나씩</code>만 배포 된다.</p>\n<p>이런 형태의 워크로드는 서버의 모니터링이나 로그 수집 용도로 많이 사용되는데<br>\nDS의 다른 특징중 하나는, <code class=\"language-text\">특정 Node들에만 Pod가 하나씩</code>만 배포 되도록 설정이 가능하다.</p>\n<p>로그나 모니터링 시나리오에서 특정 장비에 대한 모니터링을 하고자 할 때 이런 시나리오가 유효하다.<br>\n예를 들어 특정 장비(노드)에만 Nvme SSD를 사용하거나 GPU를 사용할 경우 그 장비가 설치된 노드만을 모니터링하면 된다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93284066-cbc1e780-f80c-11ea-8908-ae3a5fdb5551.png\" alt=\"스크린샷, 2020-09-16 11-07-18\"></p>\n<p>DS는 특정 노드에만 Pod를 배포할 수 있도록 Pod의 <code class=\"language-text\">“node selector”</code>를 이용해서 특정 노드만을 선택할 수 있게 지원한다. </p>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"🤦♂️-job\" style=\"position:relative;\"><a href=\"#%F0%9F%A4%A6%E2%99%82%EF%B8%8F-job\" aria-label=\"🤦♂️ job permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🤦‍♂️ Job</h2>\n<p>워크로드 모델중에서 배치나 한번 실행되고 끝나는 형태의 작업이 있을 수 있다.<br>\n예를 들어 원타임으로 파일 변환 작업을 하거나, 또는 주기적으로 ETL 배치 작업을 하는 경우에는 웹서버 처럼 계속 Pod가 떠 있을 필요없이 작업을 할때만 Pod 를 띄우면 된다.\n이러한 형태의 워크로드 모델을 지원하는 컨트롤러를 Job이라고 한다</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93284286-47239900-f80d-11ea-87f1-309f3ebefac2.png\" alt=\"스크린샷, 2020-09-16 11-10-43\"></p>\n<p>Job에 의해서 관리되는 Pod는 Job이 종료되면, Pod 를 같이 종료한다.</p>\n<p>Job을 정의할때는 보통 아래와 같이 컨테이너 스펙 부분에 image 뿐만 아니라<br>\n컨테이너에서 Job을 수행하기 위한 커맨드(command) 를 같이 입력한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\">apiVersion<span class=\"token punctuation\">:</span> batch<span class=\"token operator\">/</span><span class=\"token class-name\">v1</span>\nkind<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Job</span>\nmetadata<span class=\"token punctuation\">:</span>\nname<span class=\"token punctuation\">:</span> <span class=\"token class-name\">pi</span>\nspec<span class=\"token punctuation\">:</span>\ntemplate<span class=\"token punctuation\">:</span>\n    spec<span class=\"token punctuation\">:</span>\n    containers<span class=\"token punctuation\">:</span>\n    <span class=\"token operator\">-</span> name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">pi</span>\n        image<span class=\"token punctuation\">:</span> <span class=\"token class-name\">perl</span>\n        command<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"perl\"</span><span class=\"token punctuation\">,</span>  <span class=\"token string\">\"-Mbignum=bpi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-wle\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"print bpi(2000)\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span>#####\n    restartPolicy<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Never</span>\nbackoffLimit<span class=\"token punctuation\">:</span> <span class=\"token number\">4</span></code></pre></div>\n<br/>\n<p>Job 컨트롤러에 의해서 실행된 Pod 는 이 command의 실행 결과에 따라서 Job이 실패한지 성공한지를 판단한다.<br>\n(프로세스의 exit 코드로 판단)<br>\nJob이 종료되었는데, 결과가 실패라면,이 Job을 재실행할지 또는 끝낼지를 설정에 따라서 결정한다.</p>\n<p><code class=\"language-text\">하지만 만약 Job이 끝나기 전에 비정상적으로 종료된다면 어떻게 될것인가?</code> </p>\n<p>쿠버네티스 클러스터에서 특정 노드가 장애가 났다고 가정하자<br>\nRC/RS에 의해서 관리되고 있는 Pod 는 자동으로 다른 노드에서 다시 자동으로 생성되서 시작될것이고<br>\n컨트롤러에 의해 관리되고 있지 않은 Pod 는 다시 다른 노드에서 기동되지 않고 사라질것이다.</p>\n<p>그렇다면 Job 에 의해서 관리되는 Pod는 어떻게 될것인가?\n<img src=\"https://user-images.githubusercontent.com/69498804/93284493-cd3fdf80-f80d-11ea-83f6-2288a32ecf66.png\" alt=\"스크린샷, 2020-09-16 11-14-31\"></p>\n<p>두가지 방법이 있다.  </p>\n<ol>\n<li>장애시 다시 시작하게 하거나  </li>\n<li>장애시 다시 시작하지 않게 할 수 있다. </li>\n</ol>\n<p>다시 시작의 개념은 작업의 상태가 보장되는것이 아닌<br>\n다시 처음부터 작업이 재 시작되는 것이기 때문에 resume이 아닌 restart의 개념이다.<br>\n다시 시작 처음부터 작업을 시작하더라도 데이타가 겹치거나 문제가 없는 형태여야 한다. </p>\n<p>배치 작업의 경우 작업을 한번만 실행할 수 도 있지만<br>\n같은 작업을 연속해서 여러번 수행하는 경우가 있다. (데이타가 클 경우 범위를 나눠서 작업하는 경우)<br>\n이런 경우를 위해서 Job 컨트롤러는 같은 Pod를 순차적으로, 여러번 실행할 수 있도록 설정이 가능하다.<br>\nJob 설정에서 <code class=\"language-text\">completion</code>에 횟수를 주면, 같은 작업을 completion 횟수만큼 순차적으로 반복한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93284745-417a8300-f80e-11ea-80d6-a46f2fc77297.png\" alt=\"스크린샷, 2020-09-16 11-17-47\"></p>\n<br/>\n<p>만약 여러 작업을 처리해야 하지만 순차성이 필요없고 병렬로 처리를 하고 싶다면<br>\nJob설정에서 <code class=\"language-text\">parallelism</code> 에 동시 실행할 수 있는 Pod의 수를 주면<br>\n지정된 수 만큼 Pod를 실행하여 completion 횟수를 병렬로 처리한다.<br>\n아래 그림은 completion이 5, parallelism이 2일 경우<br>\n하나의 노드에서 모든 Pod가 실행된다고 가정했을때, 실행 순서를 보여주는 그림이다. </p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/93284830-7686d580-f80e-11ea-8764-1b9c6fafd424.png\" alt=\"스크린샷, 2020-09-16 11-19-14\"></p>\n<p>요약 : 총 2개의 POD 에서 병렬 실행, 5번 반복!!</p>\n<br/>\n<hr>\n<h2 id=\"-cron-jobs\" style=\"position:relative;\"><a href=\"#-cron-jobs\" aria-label=\" cron jobs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌹 Cron jobs</h2>\n<p>Job 컨트롤러에 의해서 실행되는 배치성 작업들에 대해서 고려할 점 중 하나는<br>\n이런 배치성 작업을 메뉴얼로 실행하는 것이 아닌 주기적으로 자동화해서 실행할 필요가 있다는 것이다.<br>\n이렇게 주기적으로 정해진 스케쥴에 따라 Job 컨트롤러에 의해 작업을 실행해주는 역할이다. </p>\n<p>아래는 cron jobs 컨트롤러의 예제인데, job 컨트롤러와 설정이 다르지 않다. </p>\n<div class=\"gatsby-highlight\" data-language=\"cs\"><pre class=\"language-cs\"><code class=\"language-cs\">apiVersion<span class=\"token punctuation\">:</span> batch<span class=\"token operator\">/</span><span class=\"token class-name\">v1beta1</span>\nkind<span class=\"token punctuation\">:</span> <span class=\"token class-name\">CronJob</span>\nmetadata<span class=\"token punctuation\">:</span>\nname<span class=\"token punctuation\">:</span> <span class=\"token class-name\">hello</span>\nspec<span class=\"token punctuation\">:</span>\nschedule<span class=\"token punctuation\">:</span> <span class=\"token string\">\"*/1 * * * *\"</span>\njobTemplate<span class=\"token punctuation\">:</span>\n    spec<span class=\"token punctuation\">:</span>\n    template<span class=\"token punctuation\">:</span>\n        spec<span class=\"token punctuation\">:</span>\n        containers<span class=\"token punctuation\">:</span>\n        <span class=\"token operator\">-</span> name<span class=\"token punctuation\">:</span> <span class=\"token class-name\">hello</span>\n            image<span class=\"token punctuation\">:</span> <span class=\"token class-name\">busybox</span>\n            args<span class=\"token punctuation\">:</span>\n            <span class=\"token operator\">-</span> <span class=\"token operator\">/</span>bin<span class=\"token operator\">/</span>sh\n            <span class=\"token operator\">-</span> <span class=\"token operator\">-</span>c\n            <span class=\"token operator\">-</span> date<span class=\"token punctuation\">;</span> echo Hello <span class=\"token keyword\">from</span> the Kubernetes <span class=\"token class-name\">cluster</span>\n        restartPolicy<span class=\"token punctuation\">:</span> OnFailure</code></pre></div>\n<p>다른 점은 CronJob 스펙 설정 부분에 <code class=\"language-text\">“schedule”</code>이라는 항목이 있고 반복 조건을 unix cron과 같이 설정하면 된다. </p>\n<hr>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC\">✔ 개념정리</a></p>\n<ul>\n<li><a href=\"#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8\">오브젝트</a></li>\n<li><a href=\"#%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%8A%A4%ED%8E%99-object-spec\">오브젝트 스펙 (Object Spec)</a></li>\n<li><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-basic-object\">기본 오브젝트 (Basic Object)</a></li>\n</ul>\n</li>\n<li><a href=\"#-pod\">✌ Pod</a></li>\n<li><a href=\"#-volume\">👍 Volume</a></li>\n<li><a href=\"#-service\">👌 Service</a></li>\n<li><a href=\"#-name-space\">👏 Name space</a></li>\n<li><a href=\"#-%EB%9D%BC%EB%B2%A8label\">🐱‍🏍 라벨(label)</a></li>\n<li><a href=\"#-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\">🎶 컨트롤러</a></li>\n<li><a href=\"#-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4-%EB%B0%B0%ED%8F%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4\">😃 쿠버네티스 배포에 대한 이해</a></li>\n<li><a href=\"#-%EA%B3%A0%EA%B8%89-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC\">✨ 고급 컨트롤러</a></li>\n<li><a href=\"#%F0%9F%A4%A6%E2%99%82%EF%B8%8F-job\">🤦‍♂️ Job</a></li>\n<li><a href=\"#-cron-jobs\">🌹 Cron jobs</a></li>\n</ul>\n</div>","excerpt":"머리말   이전 포스트에서 드디어 GCP 인스턴스 기반의 k8s 클러스터 환경을 구축했습니다. 이번 포스트에서는 이번에 간단하게 포스트해서 정리했지만 실제 실습을 들어가기전 전체적인 개념에 대해서 다시 한번 정리하고 실습에 들어가야 할 것 같아서 조대협님의 블로그 글을 참고하여 내 식대로 다시 정리해보았다.   참고  :  조대협님 블로그 ✔ 개념정리 오브젝트 쿠버네티스를 이해하기 위해 가장 중요한 부분이 이다. 가장 가 되는  를 하고 하는 추가적인 기능을 가진  이러한 오브젝트의 이외에 추가정보인 들로 구성이 된다고 보면 된다.  오브젝트 스펙 (Object Spec) 오브젝트들은 모두 오브젝트의 특성 (설정정보)…","frontmatter":{"date":"June 29, 2021","title":"[Kubernetes] - 쿠버네티스의 컴포넌트","categories":"DevOps","author":"nasa1515","emoji":"🤦‍♂️"},"fields":{"slug":"/kubernetes-componant/"}},"next":{"id":"b10caab8-cb55-5a70-84d6-bbb3cda063ef","html":"<h2 id=\"-발생-에러\" style=\"position:relative;\"><a href=\"#-%EB%B0%9C%EC%83%9D-%EC%97%90%EB%9F%AC\" aria-label=\" 발생 에러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✔ 발생 에러</h2>\n<p>상황 : kubespray로 <code class=\"language-text\">ansible-playbook</code> 명령어 구동 중 “assertion: groups.etcd | length is not divisibleby 2” 에러 발생”</p>\n<br/>\n<ul>\n<li>\n<p>kubespray로 <code class=\"language-text\">ansible-playbook</code> 명령어 진행 시 <code class=\"language-text\">\"assertion: groups.etcd | length is not divisibleby 2\"</code> 에러가 발생할 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/90841029-8db0df80-e396-11ea-9580-2521ddd039ff.png\" alt=\"스크린샷, 2020-08-21 10-10-28\"></p>\n<p>캡쳐 이미지를 보면 특정노드는 성공했는데 특정노드는 실패했습니다</p>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"-원인\" style=\"position:relative;\"><a href=\"#-%EC%9B%90%EC%9D%B8\" aria-label=\" 원인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✌ 원인</h2>\n<ul>\n<li>\n<p>해당 에러는 아래 이미지와 같이 <code class=\"language-text\">inventory.ini</code> 파일에 지정한 <code class=\"language-text\">etcd</code>가 <code class=\"language-text\">짝수</code>인 경우에 발생합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/90841122-d10b4e00-e396-11ea-9848-425e4215a799.png\" alt=\"스크린샷, 2020-08-21 10-12-18\"></p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p>kubespray/roles/kubernetes/preinstall/tasks/0020-verify-settings.yml 코드 확인</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/90841237-25aec900-e397-11ea-9519-93ec3550d18a.png\" alt=\"스크린샷, 2020-08-21 10-14-45\"></p>\n<p>해당 코드가 <code class=\"language-text\">etcd</code>의 갯수가 짝수일 경우에 에러를 표출합니다</p>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"해결\" style=\"position:relative;\"><a href=\"#%ED%95%B4%EA%B2%B0\" aria-label=\"해결 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👍해결</h2>\n<ul>\n<li>\n<p>문제해결하기 위해선 <code class=\"language-text\">etcd를 홀수</code>로 설정하거나 <code class=\"language-text\">-e ignore_assert_errors=yes</code> 옵션을 추가하여 해결 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># ex\nansible-playbook -i kubespray/inventory/cluster/inventory.ini \\\n-v --become --become-user=root kubespray/cluster.yml -e ignore_assert_errors=yes</code></pre></div>\n</li>\n</ul>\n<br/>\n<ul>\n<li>저같은 경우 테스트용이라서 특정 노드를 <code class=\"language-text\">etcd</code>로 하나 추가해 해결 후 설치까지 확인 했습니다.</li>\n</ul>\n<br/>\n<ul>\n<li><code class=\"language-text\">설정파일</code>\n<img src=\"https://user-images.githubusercontent.com/69498804/90841465-b7b6d180-e397-11ea-9c8b-a129f1e9b5ce.png\" alt=\"스크린샷, 2020-08-21 10-18-49\"></li>\n</ul>\n<br/>\n<ul>\n<li>\n<p>정상적으로 설치가 되었습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/90844636-5692fc00-e39f-11ea-9bce-2d1bea280a1c.png\" alt=\"스크린샷, 2020-08-21 11-11-23\">\n<code class=\"language-text\">skipped</code>이 많긴하지만 여러 테스트를 하며 설치를 해서 상관없습니다</p>\n</li>\n</ul>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">root 권한</code>으로 <code class=\"language-text\">노드 정보</code>를 정상적으로 받아옴을 확인합니다</p>\n<p><img src=\"https://user-images.githubusercontent.com/69498804/90846161-91e2fa00-e3a2-11ea-86e4-cbaf96a90258.png\" alt=\"스크린샷, 2020-08-21 11-36-30\"></p>\n</li>\n</ul>\n<br/>\n<hr>\n<h2 id=\"권장\" style=\"position:relative;\"><a href=\"#%EA%B6%8C%EC%9E%A5\" aria-label=\"권장 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👏권장</h2>\n<h3 id=\"etcd는-홀수로-사용하는것을-권장-합니다\" style=\"position:relative;\"><a href=\"#etcd%EB%8A%94-%ED%99%80%EC%88%98%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B2%83%EC%9D%84-%EA%B6%8C%EC%9E%A5-%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"etcd는 홀수로 사용하는것을 권장 합니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>etcd는 홀수로 사용하는것을 권장 합니다.</h3>\n<p>짝수로 사용할 경우 <code class=\"language-text\">스플릿 브레인(Split Brain)</code> 현상이 발생하여 네트워크 단절로 인한 통신 장애 등 문제가 발생 할 여지가 존재합니다.<br>\n이러한 이유로 실제 서비스 환경에서는 etcd 클러스터를 홀수로 사용하는 것이 좋습니다.</p>\n<br/>\n<ul>\n<li>\n<p><code class=\"language-text\">스플릿 브레인(Split Brain)</code></p>\n<p>일반적으로 클러스터로 구성된 두 시스템 그룹간 네트워크의 일시적 동시 단절현상이 발생 시 나타나는 현상.</p>\n<p>클러스터 상의 모든 노드들은 노드 각자가 자신을 <code class=\"language-text\">primary</code>라고 인식하게 되는 상황을 말합니다.<br>\n즉, 어느 특정 리소스에 대한 두 시스템 그룹 간의 모든 네트워크 연결이 동시에 실패하면 네트워크 파티션이 발생합니다.<br>\n이러한 상태가 발생하면 파티션 양쪽의 시스템이 각각 반대쪽에서 응용 프로그램을 재시작하여<br>\n<code class=\"language-text\">중복 서비스 또는 \"스플릿 브레인(split-brain)\"</code>을 유발합니다.  </p>\n<p><code class=\"language-text\">스플릿 브레인(split-brain)</code>은 클러스터로 구성된 독립적인 두 시스템이<br>\n<code class=\"language-text\">특정 리소스(일반적으로 파일 시스템 또는 볼륨)</code>에 대한 <code class=\"language-text\">배타적 액세스</code> 권한이 있다고 가정할 경우에 발생합니다.  </p>\n<p>네트워크 파티션으로 인해 발생하는 가장 심각한 문제는 <code class=\"language-text\">공유 디스크의 데이터</code>에 <code class=\"language-text\">영향</code>을 준다는 점입니다.</p>\n</li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EB%B0%9C%EC%83%9D-%EC%97%90%EB%9F%AC\">✔ 발생 에러</a></li>\n<li><a href=\"#-%EC%9B%90%EC%9D%B8\">✌ 원인</a></li>\n<li><a href=\"#%ED%95%B4%EA%B2%B0\">👍해결</a></li>\n<li>\n<p><a href=\"#%EA%B6%8C%EC%9E%A5\">👏권장</a></p>\n<ul>\n<li><a href=\"#etcd%EB%8A%94-%ED%99%80%EC%88%98%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B2%83%EC%9D%84-%EA%B6%8C%EC%9E%A5-%ED%95%A9%EB%8B%88%EB%8B%A4\">etcd는 홀수로 사용하는것을 권장 합니다.</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 29, 2021","title":"[Error Report] - length is not divisibleby 2","categories":"DevOps Error-Report","author":"nasa1515","emoji":"🤦‍♂️"},"fields":{"slug":"/kubernetes-error1/"}},"prev":{"id":"85b868eb-f8db-5212-ac16-bf9c82a6dddc","html":"<p>머리말 </p>\n<p>이전 포스트에서 쿠버네티스의 기본적인 컴포넌트 개념에 대해서 정리 해보았습니다.<br>\n이번에는 실습에 들어가기 앞서 아키텍쳐의 개념을 잡고 들어가기위해서<br>\n조대협님의 블로그 글을 참고하여 제 식대로 다시 정리 해보았습니다.  </p>\n<hr>\n<p>참고  :  <a href=\"https://bcho.tistory.com/1258?category=731548\">조대협님 블로그</a></p>\n<hr>\n<h2 id=\"-아키텍쳐-개념정리\" style=\"position:relative;\"><a href=\"#-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC\" aria-label=\" 아키텍쳐 개념정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✔ 아키텍쳐 개념정리</h2>\n<p>이전 포스트에서 쿠버네티스에 대한 개념 이해가 끝났으면<br>\n이제 쿠버네티스가 실제로 어떤 구조로 구현이 되어 있는지 아키텍쳐를 살펴보도록 하자.<br>\n아키텍쳐를 이용하면 동작 원리를 이해할 수 있기 때문에 쿠버네티스의 사용법을 이해하는데 도움이 된다.</p>\n<p>(kubernetes의 아키텍쳐)<br>\n<img src=\"https://user-images.githubusercontent.com/69498804/93286404-1eea6900-f812-11ea-8a90-dc6e79166d83.png\" alt=\"스크린샷, 2020-09-16 11-45-17\"></p>\n<br/>\n<h2 id=\"-마스터와-노드\" style=\"position:relative;\"><a href=\"#-%EB%A7%88%EC%8A%A4%ED%84%B0%EC%99%80-%EB%85%B8%EB%93%9C\" aria-label=\" 마스터와 노드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✌ 마스터와 노드</h2>\n<p>쿠버네티스는 크게 마스터(Master)와 노드(Node) 두 개의 컴포넌트로 분리된다.</p>\n<p>마스터는 쿠버네티스의 설정 환경을 저장하고 전체 클러스터를 관리하는 역할을 맏고<br>\n노드는 파드나 컨테이너 처럼 쿠버네티스 위에서 동작하는 워크로드를 호스팅하는 역할을 한다.</p>\n<br/>\n<h3 id=\"마스터\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%8A%A4%ED%84%B0\" aria-label=\"마스터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마스터</h3>\n<p>쿠버네티스 클러스터 전체를 컨트럴 하는 시스템 크게 API 서버, 스케쥴러, 컨트롤러 매니져, etcd 로 구성되어 있다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">API 서버</code>  </p>\n<p>쿠버네티스는 모든 명령과 통신을 API를 통해서 하는데 그 중심이 되는 서버가 API서버이다.<br>\n쿠버네티스의 모든 기능들을 REST API로 제공하고 그에 대한 명령을 처리한다.  </p>\n</li>\n<li>\n<p><code class=\"language-text\">Etcd</code>  </p>\n<p>API 서버가 명령을 주고 받는 서버라면<br>\n쿠버네티스 클러스터의 데이타 베이스 역할의 서버로 설정값이나 클러스터의 상태를 저장하는 서버이다.<br>\netcd라는 분산형 키/밸류 스토어 오픈소스 ()<a href=\"https://github.com/coreos/etcd\">https://github.com/coreos/etcd</a>) 로<br>\n쿠버네티스 클러스터의 상태나 설정 정보를 저장한다.   </p>\n</li>\n<li>\n<p><code class=\"language-text\">스케쥴러</code>  </p>\n<p>스케쥴러는 Pod,서비스등 각 리소스들을 적절한 노드에 할당하는 역할을 한다.</p>\n</li>\n<li>\n<p><code class=\"language-text\">컨트롤러 매니져</code> : 컨트롤러 들을 생성하고 이를 각 노드에 배포하며 이를 관리하는 역할을 한다</p>\n<ul>\n<li>Replica controller</li>\n<li>Service controller</li>\n<li>Volume Controller</li>\n<li>Node controller   </li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">DNS</code>  </p>\n<p>맨위의 그림에는 빠져있는데 쿠버네티스는 리소스의 엔드포인트(Endpoint)를 DNS로 맵핑하고 관리한다.<br>\nPod나 서비스등은 IP를 배정받는데 동적으로 생성되는 리소스이기 때문에 그 IP 주소가 그때마다 변경이 되어<br>\n그 리소스에 대한 위치 정보가 필요한데 이러한 패턴을 Service discovery 패턴이라고 한다.<br>\n쿠버네티스에서는 이를 내부 DNS서버를 두는 방식으로 해결하였다.</p>\n<p>즉 새로운 리소스가 생기면 그 리소스에 대한 IP와 DNS 이름을 등록하여 DNS 이름을 기반으로 리소스에 접근할 수 있도록 한다.</p>\n</li>\n</ul>\n<br/>\n<hr>\n<h3 id=\"노드\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C\" aria-label=\"노드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드</h3>\n<p>노드는 마스터에 의해 명령을 받고 실제 워크로드를 생성하여 서비스 하는 컴포넌트이다.<br>\n노드에는 Kubelet, Kube-proxy,cAdvisor 그리고 컨테이너 런타임이 배포된다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">Kubelet</code>  </p>\n<p>노드에 배포되는 에이전트 마스터의 API서버와 통신을 하면서, 노드가 수행해야 할 명령을 받아서 수행하고<br>\n반대로 노드의 상태등을 마스터로 전달하는 역할을 한다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">Kube-proxy</code> </p>\n<p>노드로 들어오는 네트워크 트래픽을 적절한 컨테이너로 라우팅하고 로드밸런싱등<br>\n노드로 들어오고 나가는 네트워크 트래픽을 프록시하고 노드와 마스터간의 네트워크 통신을 관리한다. </p>\n</li>\n<li>\n<p><code class=\"language-text\">Container runtime</code>  </p>\n<p>Pod를 통해서 배포된 컨테이너를 실행하는 컨테이너 런타임이다.<br>\n보통 도커 컨테이너를 생각하기 쉬운데 도커 이외에도 rkt (보안이 강화된 컨테이너), Hyper container 등 다양한 런타임이 있다.</p>\n</li>\n<li><code class=\"language-text\">cAdvisor</code><br>\ncAdvisor는 각 노드에서 기동되는 모니터링 에이전트이다.<br>\n노드내에서 가동되는 컨테이너들의 상태와 성능등의 정보를 수집하여 마스터 서버의 API 서버로 전달한다.<br>\n이 데이타들은 주로 모니터링을 위해서 사용된다.</li>\n</ul>\n<hr>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC\">✔ 아키텍쳐 개념정리</a></li>\n<li>\n<p><a href=\"#-%EB%A7%88%EC%8A%A4%ED%84%B0%EC%99%80-%EB%85%B8%EB%93%9C\">✌ 마스터와 노드</a></p>\n<ul>\n<li><a href=\"#%EB%A7%88%EC%8A%A4%ED%84%B0\">마스터</a></li>\n<li><a href=\"#%EB%85%B8%EB%93%9C\">노드</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"June 29, 2021","title":"[Kubernetes] - 쿠버네티스의 아키텍쳐","categories":"DevOps","author":"nasa1515","emoji":"🤦‍♂️"},"fields":{"slug":"/kubernetes-architecture/"}},"site":{"siteMetadata":{"siteUrl":"https://nasa1515.com","comments":{"utterances":{"repo":"nasa1515/nasablog"}}}}},"pageContext":{"slug":"/kubernetes-componant/","nextSlug":"/kubernetes-error1/","prevSlug":"/kubernetes-architecture/"}},"staticQueryHashes":["1073350324","2938748437"]}